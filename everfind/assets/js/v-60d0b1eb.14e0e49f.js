(self.webpackChunkeverfind=self.webpackChunkeverfind||[]).push([[982],{2729:(F,e,r)=>{"use strict";r.r(e),r.d(e,{data:()=>t});const t={key:"v-60d0b1eb",path:"/solutions/graphql/bff.html",title:"深入理解 BFF",lang:"zh-CN",frontmatter:{title:"深入理解 BFF",description:"什么是 BFF？如何建设 BFF？",keywords:["BFF"],date:"2021-06-23T00:00:00.000Z",key:1,permalinkPattern:"solutions/graphql/:slug.html",tags:["概念"]},excerpt:"",headers:[{level:2,title:"BFF 的诞生背景",slug:"bff-的诞生背景",children:[]},{level:2,title:"什么是 BFF，以及如何构建 BFF？",slug:"什么是-bff-以及如何构建-bff",children:[]},{level:2,title:"BFF 带来了哪些挑战？",slug:"bff-带来了哪些挑战",children:[]},{level:2,title:"参考文献",slug:"参考文献",children:[]}],filePathRelative:"solutions/graphql/bff.md"}},8435:(F,e,r)=>{"use strict";r.r(e),r.d(e,{default:()=>s});var t=r(6252);const l=(0,t.uE)('<div class="custom-container tip"><p class="custom-container-title">TIP</p><p>BFF（Backend For Frontend）这个模式出来很多年了，业界也有很多不错的实践。本文旨在对什么是 BFF，以及在什么情况下适合使用 BFF 做一些说明。</p></div><h2 id="bff-的诞生背景"><a class="header-anchor" href="#bff-的诞生背景">#</a> BFF 的诞生背景</h2><p>在互联网的发展过程中，Web 应用的功能变得越来越丰富。极端情况下，有一些页面甚至需要调用几十个接口来完成数据的获取。随着移动互联网的发展，移动 APP、H5 页面大大拓宽了前端的工作领域，同时也带来了多样的页面数据获取需求。</p><p>在传统的开发模式中，后端服务直接为前端页面提供 API 接口。换句话说，后端的接口设计受页面的影响非常大。在互联网场景下，前端页面的变化是非常快的，也就意味着后端的接口也要跟着变。那么，势必会影响到后端的领域能力沉淀。同时，由于不同的 UI 端对数据的需求不尽相同，后端往往需要针对不同的端提供定制化的接口，这加剧了这个问题的影响。</p><p>那么，如何才能有效解决这个问题呢？</p><h2 id="什么是-bff-以及如何构建-bff"><a class="header-anchor" href="#什么是-bff-以及如何构建-bff">#</a> 什么是 BFF，以及如何构建 BFF？</h2><p>BFF 全称是 Backend For Frontend。这里面有两个关键词，一个是 BFF 的服务对象，即 BFF 是为前端数据服务的。一个是 BFF 的本身存在形式，BFF 是一个后端服务，负责对后端领域数据接口进行聚合、裁剪以及编排。</p><p>搞清楚了 BFF 是做什么的之后，在开始构建 BFF 之前，我们还需要明确几个问题。</p><h4 id="_1-谁来构建-bff"><a class="header-anchor" href="#_1-谁来构建-bff">#</a> 1. 谁来构建 BFF？</h4><p>BFF 处在后端服务和前端页面之间，就像是一层胶水，将后端的领域能力和前端差异化的数据展示粘合在一起。在满足前端高频的变更需求的同时，将对后端领域能力建设的影响降低至最低。</p><p>从这个角度出发，我认为 BFF 应该由更贴近于 UI 的团队来建设。因为只有了解 UI 的人才能确切的知道页面需要什么数据。如果 BFF 由后端团队来构建的话，那么 UI 团队就需要根后端团队针对页面的需求反复的沟通。跨团队的沟通成本是很高的。当然，由 UI 团队来构建 BFF，UI 团队还是需要与后端团队针对领域业务能力做一些沟通的，但是相对于频繁变化的 UI 页面来说，沟通的频次将大大降低。</p><h4 id="_2-如何划分-bff"><a class="header-anchor" href="#_2-如何划分-bff">#</a> 2. 如何划分 BFF？</h4><p>有如下几种划分思路。</p><p><strong>一种是按产品划分。</strong></p><p>比如在电商业务中，商城相关的是一个产品，划分为一个 BFF，账号体系是一个产品，划分为一个 BFF。</p><p>这种划分方式显得有点简单粗暴，最大的优势是能够做到非常简单的接口以及代码复用。但是缺点也很明显。我们知道，一个产品往往会覆盖不同的端，比如会有 PC、APP、H5，甚至还有小程序。不同的端对数据的需求是不同的，往往需要对接口进行微调，针对不同的端进行差异化适配。同时，当业务发展到一定规模时，一个产品往往会有多个团队一同开发，那么多个团队一起开发维护一个 BFF 的协作成本也相对较高。</p><p><strong>第二种是按照模块来划分。</strong></p><p>比如商城中还可以划分为商品列表、商品详情、支付等子模块，这种划分方法与第一种没有本质上的区别，只是将 BFF 的粒度拆分的更细，缩小了 BFF 的规模，降低业务系统庞大带来的复杂性。</p><p>这种方式的优缺点与第一种方式类似，优点是各个模块的 BFF 更加专注，有利于团队的分工协作，同时也保证了一定的代码复用。缺点是依然需要针对各个端做差异化适配。同时，由于 BFF 拆分的更细，也带来了一些维护成本和网络调用开销。</p><p><strong>第三种是按照 UI 端来划分</strong></p><p>准确的说是按照 UI 来划分。比如 PC Web 可以划分为一个 BFF，移动 APP 可以划分为一个 BFF。如果在移动 APP 中，Android 和 IOS 差异较大，我们还可以分别拆分建设 BFF。</p><p>这种划分方式的优点非常明显，可以快速的响应各个 UI 的定制化数据需求，不需要考虑各个端的兼容。缺点也很明显，会存在各个 BFF 一定程度的代码重复。</p><p>以上三种方案各有优缺点，无论哪种方式都不是完美的。我们需要根据业务形式的需要灵活的采取不同的方式。</p><h4 id="_3-构建-bff-的基本原则是什么"><a class="header-anchor" href="#_3-构建-bff-的基本原则是什么">#</a> 3. 构建 BFF 的基本原则是什么？</h4><p>BFF 作为一个沟通前后端的中间层服务，势必在建设过程中遇到很多难以确定边界的事情。比如一个功能到底是放在 BFF 做还是放在后端服务来做，有时候这样的问题最终得依赖经验丰富的开发同学来解决。</p><p>那么，我们在构建 BFF 的时候，需要确定一些基本原则，来尽量减少这类问题的发生。</p><ul><li><strong>BFF 要聚焦在对数据的聚合、裁剪和编排上</strong></li></ul><p>BFF 作为一个服务，理论上什么功能都可以做。但是我们要明确构建 BFF 的目的，就是为了解决前端页面差异化的展示需求。因此，BFF 应该聚焦在对数据的聚合、裁剪，以及在必要情况对后端接口进行一定的编排的能力。其他的问题，虽然 BFF 也可以轻松解决，但是还是要交给后端服务来实现。</p><ul><li><strong>BFF 之间禁止平级调用</strong></li></ul><p>有时候为了能尽快完成功能，会有想复用其他 BFF 上已经实现的接口的想法。在 BFF 建设过程中，我们应该极力避免这种想法的产生。因为这么做会导致 BFF 之间产生混乱的依赖关系，这与 BFF 本身的出发点是相悖的。</p><ul><li><strong>所有的 UI 都应该与 BFF 对接</strong></li></ul><p>有了 BFF 以后，我们应该将所有针对 UI 的数据支持都收口到 BFF 上来。换句话说就是所有 UI 的数据都应该从 BFF 中获取，尽量避免即从后端服务直接获取数据，又从 BFF 获取数据的情况。</p><h2 id="bff-带来了哪些挑战"><a class="header-anchor" href="#bff-带来了哪些挑战">#</a> BFF 带来了哪些挑战？</h2><p>对于前端开发人员来说，BFF 带来了一个全新的技术环境。需要开发人员快速学习并掌握服务端开发的基本技能，包括但不限于基础的服务端开发能力、基础的运维能力等。</p><p>除了硬性的技能要求以外，BFF 带给前端开发人员最大的挑战是需要开发人员更加细致的了解业务。需要从具体业务、乃至整个产品的角度来思考，这对习惯于聚焦页面展现效果的前端开发人员来说，是一个极大的工作思路的转变。</p><h2 id="参考文献"><a class="header-anchor" href="#参考文献">#</a> 参考文献</h2>',36),a={href:"https://samnewman.io/patterns/architectural/bff/",target:"_blank",rel:"noopener noreferrer"},n=(0,t.Uk)("Pattern: Backends For Frontends"),p={href:"https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B",target:"_blank",rel:"noopener noreferrer"},B=(0,t.Uk)("康威定律"),s={render:function(F,e){const r=(0,t.up)("OutboundLink");return(0,t.wg)(),(0,t.j4)(t.HY,null,[l,(0,t.Wm)("ul",null,[(0,t.Wm)("li",null,[(0,t.Wm)("a",a,[n,(0,t.Wm)(r)])]),(0,t.Wm)("li",null,[(0,t.Wm)("a",p,[B,(0,t.Wm)(r)])])])],64)}}}}]);